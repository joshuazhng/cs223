#! /usr/bin/env python
"""
Defines a class, `TestCaseGenerator`, that generates a subclass of `unittest.TestCase` containing
test methods for each of the subdirectories in some directory. An instance of `TestCaseGenerator`
has one property, `testCase`, which is an instance of that class.
"""

import subprocess
from typing import Callable
from unittest import TestCase

from pathlib import Path
import gradescope_utils.autograder_utils.decorators as gs


class TestCaseGenerator:
    """
    Class for generating an instance of `unittest.TestCase` from a series of input/output files.
    """

    VISIBLE = "visible"
    HIDDEN = "hidden"

    _IN_FILE = "in"
    _ARGS_FILE = "args"
    _DOC_FILE = "doc"
    _OUT_FILE = "out"
    _ERR_FILE = "err"
    _CODE_FILE = "status"

    def __init__(self, testsdir: Path, exep: Path, /, visibility=VISIBLE) -> None:
        class Generated(TestCase):
            """Class of test cases for a simple input/output autograder.

            Test cases are generated for this class from files in `testsdir`.
            """

            def setUp(self) -> None:
                self.maxDiff = None
                return super().setUp()

        self._testCase = Generated

        self._tests_dir = testsdir
        self._exep = exep
        self._visilbility = visibility

        for test in sorted(filter(Path.is_dir, Path(self._tests_dir).glob("*"))):
            if test.is_dir():
                testname = f"test_{self._visilbility}_{test.name}"

                testmethod = self._generate_input_output_method(
                    test.name)
                setattr(self._testCase, testname, testmethod)

    @property
    def testCase(self):
        """The `unittest.TestCase` class that was generated by this generator."""

        return self._testCase

    @staticmethod
    def _args_from_file(args: Path) -> list[str]:
        """Read command-line arguments from file args, one argument per line."""

        if args.exists():
            with open(args, "r") as argfile:
                return [line.strip() for line in argfile]
        else:
            return []

    def _command_str(self, args: list[str], /, instream: Path | None = None) -> str:
        """Returns the command string that could be executed to run this test case."""

        command = subprocess.list2cmdline([self._exep] + args)
        if instream is not None and instream.exists():
            command += f" < {instream}"
        return command

    def _generate_input_output_method(self, tname: str) -> Callable[[TestCase], None]:
        """Returns a test method that may be added to a TestCase class, generated from the files
        in the directory named {tname} in self._tests_dir.
        """

        testsdir = self._tests_dir
        exep = self._exep

        def method(self: TestCase):
            """Generated test method.

            This function runs the executable pointed to by self._exep and compares the actual
            contents of stdout, stderr, and the exit code with the reference content in OUT_FILE,
            ERR_FILE, and CODE_FILE respectively.

            It will fail if any of those files do not exist.

            (This docstring is replaced automatically with a more useful message.)
            """

            assert self.maxDiff is None

            try:
                with open(Path(testsdir, tname, TestCaseGenerator._OUT_FILE), "r") as test_out, open(Path(testsdir, tname, TestCaseGenerator._ERR_FILE), "r") as err_out, open(Path(testsdir, tname, TestCaseGenerator._CODE_FILE), "r") as code_out:
                    program = [exep.absolute()]
                    args = TestCaseGenerator._args_from_file(
                        Path(testsdir, tname, TestCaseGenerator._ARGS_FILE))

                    infile = None
                    infilep = Path(testsdir, tname, TestCaseGenerator._IN_FILE)
                    if infilep.exists():
                        infile = infilep.open("r")
                    with subprocess.Popen(
                            program + args, stdin=infile, stdout=subprocess.PIPE, stderr=subprocess.PIPE, encoding="utf-8") as proc:
                        assert proc.stdout is not None and proc.stderr is not None
                        uut_output = proc.stdout.read()
                        ref_output = test_out.read()
                        uut_err = proc.stderr.read().strip()
                        ref_err = err_out.read().strip()
                        uut_status = proc.wait()
                        ref_status = int(code_out.read())
                        proc.terminate()

                        self.assertMultiLineEqual(uut_output, ref_output)

                        if ref_status == 0:
                            self.assertEqual(uut_status, ref_status)
                        else:
                            self.assertNotEqual(uut_status, 0)

                        if ref_err == "":
                            self.assertEqual(uut_err, ref_err)
                    if infile is not None:
                        infile.close()
            except FileNotFoundError as e:
                self.fail()

        inpath = Path(testsdir, tname, TestCaseGenerator._IN_FILE)
        arglist = TestCaseGenerator._args_from_file(
            Path(testsdir, tname, TestCaseGenerator._ARGS_FILE))
        docpath = Path(testsdir, tname, TestCaseGenerator._DOC_FILE)
        if docpath.exists():
            with open(docpath, "r") as docfile:
                method.__doc__ = docfile.read()
        else:
            method.__doc__ = self._command_str(
                arglist, instream=inpath)

        return method
